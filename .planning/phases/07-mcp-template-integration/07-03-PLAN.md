---
phase: 07-mcp-template-integration
plan: 03
type: execute
wave: 3
depends_on: ["02"]
files_modified:
  - supabase/functions/helix-mcp/index.ts
autonomous: true

must_haves:
  truths:
    - "Tool add_template_exercise adds exercise with auto order_index"
    - "Tool remove_template_exercise removes exercise from template"
    - "Tool apply_template_to_session applies with mode parameter"
    - "Prompt plan-session suggests available templates"
    - "Prompt template-analysis shows template usage statistics"
  artifacts:
    - path: "supabase/functions/helix-mcp/index.ts"
      provides: "Template exercise tools, apply tool, and prompts"
      contains: "add_template_exercise"
  key_links:
    - from: "executeTool function"
      to: "group_template_exercises table"
      via: "supabase mutations"
      pattern: 'case "add_template_exercise"'
    - from: "apply_template_to_session tool"
      to: "session_exercises table"
      via: "insert with template_id"
      pattern: "template_id: template_id"
---

<objective>
Add MCP template exercise tools, apply tool, and prompts to helix-mcp Edge Function.

Purpose: Enable AI clients to manage template exercises and apply templates to sessions.
Output: Three additional tools and two prompts (1 new, 1 enhanced) functional in helix-mcp.
</objective>

<execution_context>
@/home/toto/.claude/get-shit-done/workflows/execute-plan.md
@/home/toto/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-mcp-template-integration/07-RESEARCH.md
@.planning/phases/07-mcp-template-integration/07-02-SUMMARY.md
@supabase/functions/helix-mcp/index.ts
@src/hooks/useGroupTemplates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add template exercise and apply tool definitions</name>
  <files>supabase/functions/helix-mcp/index.ts</files>
  <action>
Add three more tool definitions to `getToolDefinitions()` function, after the CRUD tools added in Plan 02:

```typescript
{
  name: "add_template_exercise",
  description: "Aggiunge un esercizio a un template",
  inputSchema: {
    type: "object",
    properties: {
      template_id: { type: "string", description: "ID del template" },
      exercise_id: { type: "string", description: "ID dell'esercizio" },
      sets: { type: "number", description: "Numero di serie" },
      reps: { type: "number", description: "Numero di ripetizioni" },
      weight_kg: { type: "number", description: "Peso in kg" },
      duration_seconds: { type: "number", description: "Durata in secondi" },
      notes: { type: "string", description: "Note sull'esercizio" },
    },
    required: ["template_id", "exercise_id"],
  },
},
{
  name: "remove_template_exercise",
  description: "Rimuove un esercizio da un template",
  inputSchema: {
    type: "object",
    properties: {
      template_exercise_id: { type: "string", description: "ID dell'esercizio nel template" },
    },
    required: ["template_exercise_id"],
  },
},
{
  name: "apply_template_to_session",
  description: "Applica un template a una sessione, copiando gli esercizi come gruppo",
  inputSchema: {
    type: "object",
    properties: {
      template_id: { type: "string", description: "ID del template da applicare" },
      session_id: { type: "string", description: "ID della sessione" },
      mode: {
        type: "string",
        enum: ["append", "replace"],
        description: "append: aggiunge agli esercizi esistenti, replace: sostituisce solo gli esercizi di gruppo"
      },
    },
    required: ["template_id", "session_id", "mode"],
  },
},
```

Note: `mode` is REQUIRED per Phase Context decision - no default, AI must explicitly choose.
  </action>
  <verify>
Read the file and confirm all 3 additional tool definitions are present with correct inputSchema.
  </verify>
  <done>
Three template exercise/apply tool definitions added to getToolDefinitions() with proper schemas and descriptions in Italian.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement template exercise and apply tool handlers</name>
  <files>supabase/functions/helix-mcp/index.ts</files>
  <action>
Add handlers for add_template_exercise, remove_template_exercise, and apply_template_to_session in `executeTool()` switch statement, after the CRUD tool cases:

```typescript
case "add_template_exercise": {
  const { template_id, exercise_id, sets, reps, weight_kg, duration_seconds, notes } = args as {
    template_id: string
    exercise_id: string
    sets?: number
    reps?: number
    weight_kg?: number
    duration_seconds?: number
    notes?: string
  }

  // Verify template ownership
  const { data: template, error: templateErr } = await supabase
    .from("group_templates")
    .select("id")
    .eq("id", template_id)
    .eq("user_id", userId)
    .single()

  if (templateErr || !template) {
    return { content: [{ type: "text", text: "Errore: Template non trovato o non autorizzato" }] }
  }

  // Verify exercise exists and is accessible
  const { data: exercise, error: exerciseErr } = await supabase
    .from("exercises")
    .select("id, name")
    .eq("id", exercise_id)
    .or(`user_id.eq.${userId},user_id.is.null`)
    .single()

  if (exerciseErr || !exercise) {
    return { content: [{ type: "text", text: "Errore: Esercizio non trovato" }] }
  }

  // Get next order_index
  const { data: existing } = await supabase
    .from("group_template_exercises")
    .select("order_index")
    .eq("template_id", template_id)
    .order("order_index", { ascending: false })
    .limit(1)

  const nextOrder = existing && existing.length > 0 ? existing[0].order_index + 1 : 0

  // Insert exercise
  const { data, error } = await supabase
    .from("group_template_exercises")
    .insert({
      template_id,
      exercise_id,
      order_index: nextOrder,
      sets: sets || null,
      reps: reps || null,
      weight_kg: weight_kg || null,
      duration_seconds: duration_seconds || null,
      notes: notes || null,
    })
    .select("id")
    .single()

  if (error) {
    return { content: [{ type: "text", text: `Errore: ${error.message}` }] }
  }

  return { content: [{ type: "text", text: `Esercizio "${exercise.name}" aggiunto al template. ID: ${data.id}` }] }
}

case "remove_template_exercise": {
  const { template_exercise_id } = args as { template_exercise_id: string }

  // Verify ownership through template join
  const { data: existing, error: checkErr } = await supabase
    .from("group_template_exercises")
    .select("id, template:group_templates!inner(user_id)")
    .eq("id", template_exercise_id)
    .single()

  if (checkErr || !existing) {
    return { content: [{ type: "text", text: "Errore: Esercizio nel template non trovato" }] }
  }

  const templateData = existing.template as { user_id: string }
  if (templateData.user_id !== userId) {
    return { content: [{ type: "text", text: "Errore: Non autorizzato" }] }
  }

  const { error } = await supabase
    .from("group_template_exercises")
    .delete()
    .eq("id", template_exercise_id)

  if (error) {
    return { content: [{ type: "text", text: `Errore: ${error.message}` }] }
  }

  return { content: [{ type: "text", text: "Esercizio rimosso dal template." }] }
}

case "apply_template_to_session": {
  const { template_id, session_id, mode } = args as {
    template_id: string
    session_id: string
    mode: "append" | "replace"
  }

  // 1. Fetch template with exercises
  const { data: template, error: templateErr } = await supabase
    .from("group_templates")
    .select(`
      id, name,
      exercises:group_template_exercises(
        *, exercise:exercises(id, name)
      )
    `)
    .eq("id", template_id)
    .eq("user_id", userId)
    .single()

  if (templateErr || !template) {
    return { content: [{ type: "text", text: "Errore: Template non trovato o non autorizzato" }] }
  }

  const templateExercises = template.exercises as Array<{
    exercise_id: string
    order_index: number
    sets: number | null
    reps: number | null
    weight_kg: number | null
    duration_seconds: number | null
    notes: string | null
    exercise: { id: string; name: string } | null
  }>

  if (!templateExercises?.length) {
    return { content: [{ type: "text", text: "Errore: Il template non contiene esercizi" }] }
  }

  // 2. Verify session exists and belongs to user
  const { data: session, error: sessionErr } = await supabase
    .from("sessions")
    .select("id, client:clients!inner(user_id)")
    .eq("id", session_id)
    .single()

  if (sessionErr || !session) {
    return { content: [{ type: "text", text: "Errore: Sessione non trovata" }] }
  }

  const clientData = session.client as { user_id: string }
  if (clientData.user_id !== userId) {
    return { content: [{ type: "text", text: "Errore: Non autorizzato per questa sessione" }] }
  }

  // 3. If replace mode, delete existing group exercises ONLY
  if (mode === "replace") {
    const { error: deleteErr } = await supabase
      .from("session_exercises")
      .delete()
      .eq("session_id", session_id)
      .eq("is_group", true)  // CRITICAL: Only group exercises!

    if (deleteErr) {
      return { content: [{ type: "text", text: `Errore durante la rimozione: ${deleteErr.message}` }] }
    }
  }

  // 4. Get starting order_index
  const { data: existing } = await supabase
    .from("session_exercises")
    .select("order_index")
    .eq("session_id", session_id)
    .order("order_index", { ascending: false })
    .limit(1)

  const startIndex = mode === "append" ? ((existing?.[0]?.order_index ?? -1) + 1) : 0

  // 5. Insert exercises with template_id link
  const exercisesToInsert = templateExercises
    .sort((a, b) => a.order_index - b.order_index)
    .map((ex, idx) => ({
      session_id: session_id,
      exercise_id: ex.exercise_id,
      template_id: template_id,  // CRITICAL: Link to template!
      order_index: startIndex + idx,
      sets: ex.sets,
      reps: ex.reps,
      weight_kg: ex.weight_kg,
      duration_seconds: ex.duration_seconds,
      notes: ex.notes,
      is_group: true,
      completed: false,
      skipped: false,
    }))

  const { error: insertErr } = await supabase
    .from("session_exercises")
    .insert(exercisesToInsert)

  if (insertErr) {
    return { content: [{ type: "text", text: `Errore durante l'inserimento: ${insertErr.message}` }] }
  }

  const modeText = mode === "append" ? "aggiunto" : "sostituito"
  return {
    content: [{
      type: "text",
      text: `Template "${template.name}" ${modeText} alla sessione con ${exercisesToInsert.length} esercizi di gruppo.`
    }]
  }
}
```

Key points:
- add_template_exercise validates both template ownership AND exercise accessibility
- Auto-calculates next order_index (same as useGroupTemplates.addExercise)
- remove_template_exercise verifies ownership through template join
- apply_template_to_session mode='replace' MUST filter by is_group=true (preserve individual exercises)
- MUST set template_id on inserted exercises (enables edit blocking in UI)
  </action>
  <verify>
Test add_template_exercise with curl (requires valid template_id and exercise_id):
```bash
curl -s -X POST http://127.0.0.1:54321/functions/v1/helix-mcp \
  -H "Content-Type: application/json" \
  -H "X-Helix-API-Key: $TEST_API_KEY" \
  -d '{"jsonrpc": "2.0", "method": "tools/call", "id": 1, "params": {"name": "add_template_exercise", "arguments": {"template_id": "TEMPLATE_ID", "exercise_id": "EXERCISE_ID", "sets": 3, "reps": 10}}}'
```
Should return success with exercise ID.
  </verify>
  <done>
add_template_exercise, remove_template_exercise, and apply_template_to_session handlers implemented with ownership verification and proper mode handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance plan-session prompt and add template-analysis prompt</name>
  <files>supabase/functions/helix-mcp/index.ts</files>
  <action>
1. Add new prompt definition to `getPromptDefinitions()`:

```typescript
{
  name: "template-analysis",
  description: "Analizza l'utilizzo dei template di gruppo",
  arguments: [],
},
```

2. Enhance the `plan-session` prompt in `getPrompt()` to include available templates. Add after fetching exercises and before building the prompt text:

```typescript
// Fetch available group templates
const { data: templates } = await supabase
  .from("group_templates")
  .select(`
    id, name,
    exercises:group_template_exercises(
      exercise:exercises(name)
    )
  `)
  .eq("user_id", userId)
  .order("name")

const templatesList = (templates || [])
  .map(t => {
    const exerciseNames = (t.exercises as Array<{ exercise: { name: string } | null }>)
      ?.slice(0, 3)
      .map(e => e.exercise?.name)
      .filter(Boolean)
      .join(", ")
    return `- ${t.name} (ID: ${t.id}): ${exerciseNames}${t.exercises?.length > 3 ? '...' : ''}`
  })
  .join("\n") || "Nessun template disponibile"
```

Then add to the prompt text after PALESTRE DISPONIBILI:

```typescript
TEMPLATE GRUPPI DISPONIBILI:
${templatesList}
```

And update the instructions at the end:

```
Se il cliente partecipa a sessioni di gruppo, considera di usare un template esistente con il tool "apply_template_to_session".
```

3. Add `template-analysis` case in `getPrompt()`:

```typescript
case "template-analysis": {
  // Fetch templates with usage stats
  const { data: templates } = await supabase
    .from("group_templates")
    .select(`
      id, name, created_at,
      exercises:group_template_exercises(id)
    `)
    .eq("user_id", userId)
    .order("name")

  // For each template, count how many sessions use it
  const templateStats = await Promise.all(
    (templates || []).map(async (t) => {
      const { count } = await supabase
        .from("session_exercises")
        .select("session_id", { count: "exact", head: true })
        .eq("template_id", t.id)

      return {
        id: t.id,
        name: t.name,
        exercise_count: t.exercises?.length || 0,
        times_applied: count || 0,
        created_at: t.created_at,
      }
    })
  )

  const statsText = templateStats.length > 0
    ? templateStats
        .map(t => `- ${t.name}: ${t.exercise_count} esercizi, usato ${t.times_applied} volte`)
        .join("\n")
    : "Nessun template creato."

  return {
    messages: [{
      role: "user",
      content: {
        type: "text",
        text: `Analizza l'utilizzo dei template di gruppo per questo coach.

TEMPLATE DISPONIBILI:
${statsText}

Fornisci:
1. Quali template sono piu' utilizzati e perche'
2. Template poco usati che potrebbero essere eliminati
3. Suggerimenti per nuovi template basati sui pattern di utilizzo
4. Raccomandazioni per ottimizzare la gestione delle sessioni di gruppo`,
      },
    }],
  }
}
```
  </action>
  <verify>
1. Test prompts/list includes template-analysis
2. Test plan-session prompt includes template section:
```bash
curl -s -X POST http://127.0.0.1:54321/functions/v1/helix-mcp \
  -H "Content-Type: application/json" \
  -H "X-Helix-API-Key: $TEST_API_KEY" \
  -d '{"jsonrpc": "2.0", "method": "prompts/get", "id": 1, "params": {"name": "plan-session", "arguments": {"client_id": "CLIENT_ID"}}}'
```
Should include "TEMPLATE GRUPPI DISPONIBILI" section.
  </verify>
  <done>
plan-session prompt enhanced with template suggestions, template-analysis prompt added with usage statistics.
  </done>
</task>

</tasks>

<verification>
1. Run `tools/list` and confirm 6 total new tools appear (total should be 24)
2. Run `prompts/list` and confirm template-analysis appears (total should be 5)
3. Test create -> add exercise -> apply to session -> delete workflow
4. Verify apply mode='replace' preserves individual exercises
5. Verify delete fails when template is in use
6. Verify plan-session includes template suggestions
7. TypeScript compiles without errors
</verification>

<success_criteria>
- [ ] All 3 template exercise/apply tool definitions in getToolDefinitions()
- [ ] All 3 template exercise/apply tool handlers in executeTool()
- [ ] add_template_exercise auto-calculates order_index
- [ ] remove_template_exercise verifies ownership through template join
- [ ] apply_template_to_session sets template_id on exercises
- [ ] apply mode='replace' only removes is_group=true exercises
- [ ] plan-session prompt includes template suggestions
- [ ] template-analysis prompt shows usage statistics
- [ ] Error messages in Italian
</success_criteria>

<output>
After completion, create `.planning/phases/07-mcp-template-integration/07-03-SUMMARY.md`
</output>
